<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolution Visualizer (Exported)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "d3": "https://esm.sh/d3@7.8.5"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body { background-color: #020617; color: #f1f5f9; }
      /* Custom scrollbar for webkit */
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #0f172a; }
      ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #475569; }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 antialiased overflow-hidden">

    <div id="gatekeeper" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.98); z-index: 99999; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; backdrop-filter: blur(5px);">
        
        <div style="background: #1e293b; width: 60px; height: 60px; border-radius: 12px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; border: 1px solid #334155;">
            <span style="font-size: 30px; font-weight: bold; color: #22d3ee;">*</span>
        </div>

        <h1 style="color: #fff; margin: 0 0 10px 0; font-size: 24px; font-weight: bold;">Convolution Visualizer</h1>
        <p style="color: #94a3b8; max-width: 400px; margin-bottom: 30px; font-size: 14px;">
            交互式卷积运算演示平台。<br>
            如您是校外学习者，请购买离线正式版。
        </p>
        
        <div style="margin-bottom: 40px; padding: 25px; border: 1px solid #22d3ee; border-radius: 12px; background: rgba(34, 211, 238, 0.1); width: 90%; max-width: 350px;">
            <h3 style="margin-top: 0; color: #67e8f9; font-size: 18px; font-weight: bold;">获取完整离线版 (Windows/Mac)</h3>
            <ul style="text-align: left; font-size: 14px; color: #cbd5e1; margin-bottom: 20px; line-height: 1.6;">
                <li>✅ 连续/离散双模式切换</li>
                <li>✅ 6种信号波形任意组合</li>
                <li>✅ 翻转、平移、积分过程可视化</li>
            </ul>
            <a href="https://mianbaoduo.com/o/你的链接" target="_blank" style="display:block; background: #0891b2; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; font-weight: bold; font-size: 16px; transition: 0.3s; box-shadow: 0 4px 6px rgba(0,0,0,0.2);">
                即将上线
            </a>
        </div>

        <div style="border-top: 1px solid #334155; padding-top: 20px; width: 300px;">
            <p style="font-size: 13px; color: #94a3b8; margin-bottom: 10px;">本校学生请输入课程口令：</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <input type="text" id="passInput" placeholder="输入口令" style="padding: 10px; border-radius: 6px; border: 1px solid #475569; background: #0f172a; color: white; outline: none; flex: 1;">
                <button onclick="checkPass()" style="padding: 10px 20px; border-radius: 6px; background: #334155; color: white; font-weight: bold; transition: background 0.2s;">解锁</button>
            </div>
            <p id="errorMsg" style="color: #ef4444; font-size: 12px; margin-top: 10px; display: none;">口令错误</p>
        </div>
    </div>

    <script>
        // === 配置区域 ===
        // 密码: "2526123" 的 Base64 编码
        const ENCRYPTED_KEY = "MjUyNjEyMw=="; 
        const CACHE_KEY = "course_auth_convolution_2526123"; // 使用特定Key避免冲突
        // ===============

        function unlock() {
            const gate = document.getElementById('gatekeeper');
            if(gate) {
                gate.style.opacity = '0';
                gate.style.transition = 'opacity 0.5s ease';
                setTimeout(() => { 
                    gate.style.display = 'none';
                    // 触发 Resize 事件以确保 D3 图表正确渲染
                    window.dispatchEvent(new Event('resize'));
                }, 500); 
                
                // 尝试写入缓存
                try { localStorage.setItem(CACHE_KEY, ENCRYPTED_KEY); } catch (e) {}
            }
        }

        function checkPass() {
            const input = document.getElementById('passInput').value.trim();
            const errorMsg = document.getElementById('errorMsg');
            try {
                // 验证输入是否匹配
                if (btoa(input) === ENCRYPTED_KEY) unlock();
                else throw new Error();
            } catch (e) {
                errorMsg.style.display = 'block';
                const inputEl = document.getElementById('passInput');
                inputEl.style.borderColor = '#ef4444';
                inputEl.animate([
                    { transform: 'translateX(0)' },
                    { transform: 'translateX(-5px)' },
                    { transform: 'translateX(5px)' },
                    { transform: 'translateX(0)' }
                ], { duration: 300 });
            }
        }

        // 双通道自动检测逻辑
        (function initAuth() {
            let keyCandidates = [];

            // 通道 1: 查询参数 ?auth=...
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('auth')) keyCandidates.push(urlParams.get('auth'));

            // 通道 2: 哈希参数 #auth=... (抗拦截能力强)
            if (window.location.hash.includes('auth=')) {
                try {
                    const hashVal = window.location.hash.split('auth=')[1].split('&')[0];
                    if(hashVal) keyCandidates.push(decodeURIComponent(hashVal));
                } catch(e) {}
            }

            // 通道 3: 本地缓存
            try { 
                const cached = localStorage.getItem(CACHE_KEY);
                if(cached) keyCandidates.push(cached); 
            } catch(e) {}

            // 验证所有候选Key
            let isAuthorized = false;
            for (const k of keyCandidates) {
                try {
                    // 检查明文 (来自URL)
                    if (btoa(k) === ENCRYPTED_KEY) isAuthorized = true;
                    // 检查密文 (来自缓存)
                    if (k === ENCRYPTED_KEY) isAuthorized = true;
                } catch(e) {}
            }

            if (isAuthorized) {
                // 使用定时器确保 DOM 元素已加载
                const checkGate = setInterval(() => {
                    const gate = document.getElementById('gatekeeper');
                    if (gate) {
                        gate.style.display = 'none';
                        clearInterval(checkGate);
                        setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
                    }
                }, 10);
            }
        })();
    </script>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Settings, Sliders, Activity, Play, Pause, RotateCcw, FastForward, Download } from 'lucide-react';
        import * as d3 from 'd3';

        // --- Types ---
        const SignalMode = {
          Continuous: 'Continuous',
          Discrete: 'Discrete',
        };

        const SignalShape = {
          Rectangular: 'Rectangular',
          Step: 'Step',
          Exponential: 'Exponential',
          Sine: 'Sine',
          Impulse: 'Impulse',
          Triangle: 'Triangle'
        };

        // --- Math Utils ---
        const RANGE_MIN = -10;
        const RANGE_MAX = 10;
        const SAMPLE_RATE_CONT = 0.05;
        const SAMPLE_RATE_DISC = 1.0;

        const getStepSize = (mode) => 
          mode === SignalMode.Continuous ? SAMPLE_RATE_CONT : SAMPLE_RATE_DISC;

        const generateRange = (mode) => {
          const step = getStepSize(mode);
          const points = [];
          for (let i = RANGE_MIN; i <= RANGE_MAX + 1e-6; i += step) {
            points.push(i);
          }
          return points;
        };

        const getSignalFormula = (shape, params, variable = 't') => {
          const { amplitude, width, frequency, decay, offset } = params;
          const A = parseFloat(amplitude.toFixed(2));
          const off = parseFloat(offset.toFixed(2));
          const w = parseFloat((width || 1).toFixed(1));
          const f = parseFloat((frequency || 1).toFixed(1));
          const d = parseFloat((decay || 1).toFixed(1));

          if (A === 0) return "0";

          const ampStr = A === 1 ? "" : A === -1 ? "-" : `${A}`;
          const sign = off > 0 ? "-" : "+";
          const offVal = Math.abs(off);
          
          const arg = (off === 0) ? variable : `(${variable} ${sign} ${offVal})`;
          const argSimple = (off === 0) ? variable : `${variable}${sign}${offVal}`;

          switch (shape) {
            case SignalShape.Rectangular: return `${ampStr}rect(${arg}/${w})`;
            case SignalShape.Step: return `${ampStr}u(${argSimple})`;
            case SignalShape.Exponential: return `${ampStr}e^{-${d}${argSimple}}u(${argSimple})`;
            case SignalShape.Sine: return `${ampStr}sin(2π${f === 1 ? '' : f}${arg})`;
            case SignalShape.Impulse: return `${ampStr}δ(${argSimple})`;
            case SignalShape.Triangle: return `${ampStr}tri(${arg}/${w})`;
            default: return "f(t)";
          }
        };

        const evaluateSignal = (shape, params, t, mode) => {
          const { amplitude, width = 2, frequency = 1, decay = 1, offset } = params;
          let x = t - offset;

          if (mode === SignalMode.Discrete && (shape === SignalShape.Rectangular || shape === SignalShape.Triangle)) {
             x = Math.round(x);
          }

          if (mode === SignalMode.Discrete && shape === SignalShape.Impulse) {
            return Math.abs(x) < 0.1 ? amplitude : 0;
          }
          if (mode === SignalMode.Continuous && shape === SignalShape.Impulse) {
             return (Math.abs(x) < 0.05) ? amplitude * 10 : 0;
          }

          switch (shape) {
            case SignalShape.Rectangular: return Math.abs(x) <= width / 2 + 1e-6 ? amplitude : 0;
            case SignalShape.Step: return x >= 0 ? amplitude : 0;
            case SignalShape.Exponential: return x >= 0 ? amplitude * Math.exp(-decay * x) : 0;
            case SignalShape.Sine: return amplitude * Math.sin(2 * Math.PI * frequency * x);
            case SignalShape.Triangle:
              if (Math.abs(x) > width) return 0;
              return amplitude * (1 - Math.abs(x) / width);
            default: return 0;
          }
        };

        const calculateConvolution = (shapeA, paramsA, shapeB, paramsB, mode) => {
          const step = getStepSize(mode);
          const timePoints = generateRange(mode);
          const result = [];

          for (let t of timePoints) {
            let sum = 0;
            for (let tau = -20; tau <= 20; tau += step) {
              const valA = evaluateSignal(shapeA, paramsA, tau, mode);
              const valB = evaluateSignal(shapeB, paramsB, t - tau, mode);
              sum += valA * valB;
            }
            if (mode === SignalMode.Continuous) sum *= step;
            result.push({ x: t, y: sum });
          }
          return result;
        };

        const generateFrameData = (shapeA, paramsA, shapeB, paramsB, currentT, mode) => {
          const step = getStepSize(mode);
          const domain = generateRange(mode);
          const signalAData = [];
          const signalBData = [];
          const productData = [];
          let currentIntegral = 0;

          domain.forEach(tau => {
            const valA = evaluateSignal(shapeA, paramsA, tau, mode);
            const valB = evaluateSignal(shapeB, paramsB, currentT - tau, mode);
            const prod = valA * valB;

            signalAData.push({ x: tau, y: valA });
            signalBData.push({ x: tau, y: valB });
            productData.push({ x: tau, y: prod });

            if (mode === SignalMode.Continuous) {
              currentIntegral += prod * step;
            } else {
              currentIntegral += prod;
            }
          });

          return { signalAData, signalBData, productData, currentIntegral };
        };

        // --- Components ---

        const Graph = ({ dataSets, width, height, xDomain, yDomain, mode, showGrid = true, highlightX, highlightPoint, title, expression }) => {
          const margin = { top: 20, right: 30, bottom: 30, left: 40 };
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          const xScale = useMemo(() => d3.scaleLinear().domain(xDomain).range([0, innerWidth]), [xDomain, innerWidth]);
          const yScale = useMemo(() => d3.scaleLinear().domain(yDomain).range([innerHeight, 0]), [yDomain, innerHeight]);

          const xTicks = xScale.ticks(10);
          const yTicks = yScale.ticks(5);

          const generatePath = (data, type) => {
            if (type === 'area') {
                return d3.area()
                    .x(d => xScale(d.x))
                    .y0(yScale(0))
                    .y1(d => yScale(d.y))
                    .curve(mode === SignalMode.Continuous ? d3.curveMonotoneX : d3.curveStepAfter)(data) || '';
            }
            return d3.line()
              .x(d => xScale(d.x))
              .y(d => yScale(d.y))
              .curve(mode === SignalMode.Continuous ? d3.curveMonotoneX : d3.curveStepAfter)(data) || '';
          };

          return (
            <div className="relative bg-slate-900/50 rounded-lg border border-slate-700 overflow-hidden shadow-sm">
              {(title || expression) && (
                <div className="absolute top-2 left-4 z-10 pointer-events-none">
                  {title && <h4 className="text-xs font-bold text-slate-300 uppercase tracking-wide">{title}</h4>}
                  {expression && <span className="text-xs font-mono text-slate-400 bg-slate-900/80 px-1 rounded">{expression}</span>}
                </div>
              )}
              <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`} preserveAspectRatio="none" className="block">
                <g transform={`translate(${margin.left},${margin.top})`}>
                  {showGrid && (
                    <g className="opacity-20">
                      {xTicks.map(t => <line key={`xt-${t}`} x1={xScale(t)} y1={0} x2={xScale(t)} y2={innerHeight} stroke="currentColor" strokeWidth={1} />)}
                      {yTicks.map(t => <line key={`yt-${t}`} x1={0} y1={yScale(t)} x2={innerWidth} y2={yScale(t)} stroke="currentColor" strokeWidth={1} />)}
                      <line x1={0} y1={yScale(0)} x2={innerWidth} y2={yScale(0)} stroke="currentColor" strokeWidth={2} className="text-slate-400" />
                      <line x1={xScale(0)} y1={0} x2={xScale(0)} y2={innerHeight} stroke="currentColor" strokeWidth={2} className="text-slate-400" />
                    </g>
                  )}
                  <g className="text-xs fill-slate-500 font-mono">
                     {xTicks.map(t => <text key={`xtt-${t}`} x={xScale(t)} y={innerHeight + 15} textAnchor="middle">{t}</text>)}
                     {yTicks.map(t => <text key={`ytt-${t}`} x={-10} y={yScale(t) + 4} textAnchor="end">{t}</text>)}
                  </g>
                  {dataSets.map((ds, idx) => (
                    <g key={idx}>
                      {ds.type === 'area' && <path d={generatePath(ds.data, 'area')} fill={ds.color} opacity={ds.opacity || 0.3} />}
                      {mode === SignalMode.Discrete && ds.type !== 'area' ? (
                        <g>
                          {ds.data.map((d, i) => (
                            <g key={i}>
                              <line x1={xScale(d.x)} y1={yScale(0)} x2={xScale(d.x)} y2={yScale(d.y)} stroke={ds.color} strokeWidth={2} opacity={ds.opacity || 1} strokeDasharray={ds.type === 'dashed' ? '4 2' : 'none'} />
                              <circle cx={xScale(d.x)} cy={yScale(d.y)} r={3} fill={ds.color} />
                            </g>
                          ))}
                        </g>
                      ) : (
                         ds.type !== 'area' && <path d={generatePath(ds.data, 'line')} stroke={ds.color} fill="none" strokeWidth={2} strokeDasharray={ds.type === 'dashed' ? '6 4' : 'none'} opacity={ds.opacity || 1} />
                      )}
                    </g>
                  ))}
                  {highlightX !== undefined && <line x1={xScale(highlightX)} y1={0} x2={xScale(highlightX)} y2={innerHeight} stroke="#fbbf24" strokeWidth={1} strokeDasharray="4 4" />}
                  {highlightPoint && (
                     <g>
                       <circle cx={xScale(highlightPoint.x)} cy={yScale(highlightPoint.y)} r={5} className="fill-emerald-400 animate-pulse" />
                       <text x={xScale(highlightPoint.x)} y={yScale(highlightPoint.y) - 10} textAnchor="middle" className="fill-emerald-400 text-xs font-bold">{highlightPoint.y.toFixed(2)}</text>
                     </g>
                  )}
                </g>
              </svg>
            </div>
          );
        };

        const SignalControl = ({ config, setConfig, label, isSignalA }) => {
            const updateParam = (key, value) => setConfig({ ...config, params: { ...config.params, [key]: value } });
            const handleShapeChange = (e) => {
                const newType = e.target.value;
                const newParams = { ...config.params };
                if (newType === SignalShape.Rectangular || newType === SignalShape.Triangle) newParams.width = newParams.width || 2;
                if (newType === SignalShape.Sine) newParams.frequency = newParams.frequency || 1;
                if (newType === SignalShape.Exponential) newParams.decay = newParams.decay || 1;
                setConfig({ ...config, type: newType, params: newParams });
            };

            const SHAPES = Object.values(SignalShape);

            return (
                <div className="space-y-3 p-4 bg-slate-800 rounded-lg border border-slate-700">
                    <div className="flex items-center gap-2 mb-2 border-b border-slate-700 pb-2">
                        <Activity size={16} className={isSignalA ? "text-cyan-400" : "text-amber-400"} />
                        <h3 className="font-semibold text-sm uppercase tracking-wider">{label}</h3>
                    </div>
                    <div className="space-y-1">
                        <label className="text-xs text-slate-400">Shape</label>
                        <select className="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm focus:border-indigo-500 outline-none" value={config.type} onChange={handleShapeChange}>
                            {SHAPES.map(s => <option key={s} value={s}>{s}</option>)}
                        </select>
                    </div>
                    <div className="space-y-1">
                        <div className="flex justify-between"><label className="text-xs text-slate-400">Amplitude</label><span className="text-xs font-mono">{config.params.amplitude.toFixed(1)}</span></div>
                        <input type="range" min="-2" max="2" step="0.1" value={config.params.amplitude} onChange={(e) => updateParam('amplitude', parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                    </div>
                    {(config.type === SignalShape.Rectangular || config.type === SignalShape.Triangle) && (
                        <div className="space-y-1">
                            <div className="flex justify-between"><label className="text-xs text-slate-400">Width</label><span className="text-xs font-mono">{config.params.width?.toFixed(1)}</span></div>
                            <input type="range" min="0.5" max="5" step="0.5" value={config.params.width || 2} onChange={(e) => updateParam('width', parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                        </div>
                    )}
                    {config.type === SignalShape.Sine && (
                        <div className="space-y-1">
                            <div className="flex justify-between"><label className="text-xs text-slate-400">Frequency</label><span className="text-xs font-mono">{config.params.frequency?.toFixed(2)}</span></div>
                            <input type="range" min="0.1" max="2" step="0.1" value={config.params.frequency || 1} onChange={(e) => updateParam('frequency', parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                        </div>
                    )}
                    {config.type === SignalShape.Exponential && (
                        <div className="space-y-1">
                            <div className="flex justify-between"><label className="text-xs text-slate-400">Decay (b)</label><span className="text-xs font-mono">{config.params.decay?.toFixed(1)}</span></div>
                            <input type="range" min="0.1" max="3" step="0.1" value={config.params.decay || 1} onChange={(e) => updateParam('decay', parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                        </div>
                    )}
                    <div className="space-y-1">
                        <div className="flex justify-between"><label className="text-xs text-slate-400">Offset</label><span className="text-xs font-mono">{config.params.offset.toFixed(1)}</span></div>
                        <input type="range" min="-5" max="5" step="0.5" value={config.params.offset} onChange={(e) => updateParam('offset', parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                    </div>
                </div>
            );
        };

        const ControlPanel = ({ mode, setMode, configA, setConfigA, configB, setConfigB }) => {
          return (
            <div className="w-80 bg-slate-900 border-r border-slate-800 p-4 h-full overflow-y-auto flex flex-col gap-6 scrollbar-thin scrollbar-thumb-slate-700">
              <div className="flex items-center gap-2 text-indigo-400 mb-2">
                <Settings size={20} />
                <h2 className="text-lg font-bold tracking-tight text-white">Config</h2>
              </div>
              <div className="bg-slate-800 p-1 rounded-lg flex text-sm">
                <button onClick={() => setMode(SignalMode.Continuous)} className={`flex-1 py-1.5 rounded-md transition-colors ${mode === SignalMode.Continuous ? 'bg-indigo-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>Continuous</button>
                <button onClick={() => setMode(SignalMode.Discrete)} className={`flex-1 py-1.5 rounded-md transition-colors ${mode === SignalMode.Discrete ? 'bg-indigo-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>Discrete</button>
              </div>
              <SignalControl config={configA} setConfig={setConfigA} label="Fixed Signal f(τ)" isSignalA={true} />
              <div className="flex flex-col items-center justify-center text-slate-500"><Sliders size={16} className="mb-1" /><span className="text-xs italic">Convolution Operation *</span></div>
              <SignalControl config={configB} setConfig={setConfigB} label="Moving Signal g(τ)" isSignalA={false} />
              <div className="mt-auto pt-4 text-xs text-slate-500 border-t border-slate-800">
                <p>1. g(τ) is flipped to g(-τ)</p>
                <p>2. Shifted by t: g(t-τ)</p>
                <p>3. Multiplied: f(τ)·g(t-τ)</p>
                <p>4. Integrated/Summed for area</p>
              </div>
            </div>
          );
        };

        const Visualizer = ({ mode, configA, configB }) => {
          const [time, setTime] = useState(-8);
          const [isPlaying, setIsPlaying] = useState(false);
          const [speed, setSpeed] = useState(1);
          const requestRef = useRef(undefined);
          const lastTimeRef = useRef(undefined);

          const convolutionResult = useMemo(() => calculateConvolution(configA.type, configA.params, configB.type, configB.params, mode), [configA, configB, mode]);
          const frameData = useMemo(() => generateFrameData(configA.type, configA.params, configB.type, configB.params, time, mode), [configA, configB, time, mode]);

          const yDomainTop = useMemo(() => {
              const max = Math.max(Math.abs(configA.params.amplitude), Math.abs(configB.params.amplitude)) * 1.5;
              return [-Math.max(max, 1), Math.max(max, 1)];
          }, [configA, configB]);

          const yDomainResult = useMemo(() => {
              let max = 0, min = 0;
              convolutionResult.forEach(p => { if (p.y > max) max = p.y; if (p.y < min) min = p.y; });
              const range = Math.max(Math.abs(max), Math.abs(min), 1) * 1.2;
              return [-range, range];
          }, [convolutionResult]);

          const formulaA = useMemo(() => getSignalFormula(configA.type, configA.params, 'τ'), [configA]);
          const formulaB = useMemo(() => getSignalFormula(configB.type, configB.params, 'τ'), [configB]);

          const animate = (timestamp) => {
            if (lastTimeRef.current !== undefined) {
              const deltaTime = (timestamp - lastTimeRef.current) / 1000;
              setTime(prevTime => {
                const nextTime = prevTime + deltaTime * speed * 2;
                if (nextTime > 10) { setIsPlaying(false); return 10; }
                return nextTime;
              });
            }
            lastTimeRef.current = timestamp;
            if (isPlaying) requestRef.current = requestAnimationFrame(animate);
          };

          useEffect(() => {
            if (isPlaying) { lastTimeRef.current = performance.now(); requestRef.current = requestAnimationFrame(animate); }
            else { if (requestRef.current) cancelAnimationFrame(requestRef.current); lastTimeRef.current = undefined; }
            return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
          }, [isPlaying, speed]);

          const displayTime = mode === SignalMode.Discrete ? Math.round(time) : time;
          const timeVar = mode === SignalMode.Continuous ? 't' : 'n';

          return (
            <div className="flex-1 flex flex-col h-full bg-slate-950 p-6 overflow-hidden">
              <div className="flex items-center justify-between mb-4 bg-slate-900/50 p-3 rounded-xl border border-slate-800 backdrop-blur-sm">
                <div className="flex items-center gap-4">
                     <button onClick={() => setIsPlaying(!isPlaying)} className={`p-3 rounded-full transition-all ${isPlaying ? 'bg-amber-500/20 text-amber-500 hover:bg-amber-500/30' : 'bg-emerald-500 text-white hover:bg-emerald-600 shadow-lg shadow-emerald-500/20'}`}>
                        {isPlaying ? <Pause size={24} fill="currentColor" /> : <Play size={24} fill="currentColor" className="ml-1" />}
                     </button>
                     <button onClick={() => { setTime(-8); setIsPlaying(false); }} className="p-2 text-slate-400 hover:text-white transition-colors" title="Reset"><RotateCcw size={20} /></button>
                     <div className="flex flex-col w-48">
                        <div className="flex justify-between text-xs text-slate-400 mb-1"><span>Speed</span><span>{speed}x</span></div>
                        <input type="range" min="0.1" max="3" step="0.1" value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))} className="h-1 bg-slate-700 rounded appearance-none cursor-pointer" />
                     </div>
                </div>
                <div className="flex flex-col items-end">
                    <div className="text-3xl font-mono font-bold text-slate-200">{timeVar} = {displayTime.toFixed(2)}</div>
                    <div className="text-xs text-slate-500 font-mono">Current {mode === SignalMode.Continuous ? 'Area' : 'Sum'}: {frameData.currentIntegral.toFixed(3)}</div>
                </div>
              </div>
              <div className="flex gap-8 px-4 mb-2 font-mono text-slate-300 bg-slate-900/40 p-2 rounded-lg border border-slate-800/50">
                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-cyan-400 shadow-[0_0_8px_rgba(34,211,238,0.5)]"></span><span className="text-sm font-semibold">f(τ) = {formulaA}</span></div>
                <div className="w-px bg-slate-700 mx-2"></div>
                <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-amber-400 shadow-[0_0_8px_rgba(251,191,36,0.5)]"></span><span className="text-sm font-semibold">g(τ) = {formulaB}</span></div>
              </div>
              <div className="flex-1 flex flex-col gap-2 min-h-0">
                <div className="flex-1 min-h-0"><Graph width={800} height={200} xDomain={[-10, 10]} yDomain={yDomainTop} mode={mode} title="1. Alignment" expression={`f(τ) and g(${timeVar} - τ)`} dataSets={[{ data: frameData.signalAData, color: '#22d3ee', type: 'line' }, { data: frameData.signalBData, color: '#fbbf24', type: 'dashed' }]} highlightX={time} /></div>
                <div className="flex-1 min-h-0"><Graph width={800} height={200} xDomain={[-10, 10]} yDomain={yDomainTop} mode={mode} title="2. Multiplication" expression={`f(τ) · g(${timeVar} - τ)`} dataSets={[{ data: frameData.productData, color: '#a855f7', type: 'area', opacity: 0.4 }, { data: frameData.productData, color: '#c084fc', type: 'line' }]} /></div>
                <div className="flex-1 min-h-0"><Graph width={800} height={200} xDomain={[-10, 10]} yDomain={yDomainResult} mode={mode} title="3. Accumulation" expression={`y(${timeVar})`} dataSets={[{ data: convolutionResult, color: '#10b981', type: 'line' }]} highlightPoint={{ x: time, y: frameData.currentIntegral }} /></div>
              </div>
              <style>{`svg { width: 100%; height: 100%; }`}</style>
            </div>
          );
        };

        const App = () => {
          const [mode, setMode] = useState('Continuous');
          const [configA, setConfigA] = useState({"type":"Rectangular","params":{"amplitude":1,"width":2,"offset":0,"frequency":1,"decay":1}});
          const [configB, setConfigB] = useState({"type":"Rectangular","params":{"amplitude":1,"width":2,"offset":0,"frequency":1,"decay":1}});

          return (
            <div className="flex h-screen w-screen bg-slate-950 text-slate-100 font-sans">
              <ControlPanel mode={mode} setMode={setMode} configA={configA} setConfigA={setConfigA} configB={configB} setConfigB={setConfigB} />
              <main className="flex-1 flex flex-col min-w-0">
                <header className="h-14 border-b border-slate-800 flex items-center px-6 bg-slate-950">
                   <h1 className="font-bold text-xl tracking-tight bg-gradient-to-r from-indigo-400 to-cyan-400 bg-clip-text text-transparent">Convolution<span className="text-slate-500 font-light">Visualizer</span></h1>
                   <div className="ml-auto text-xs text-slate-600 font-mono">Exported Version</div>
                </header>
                <Visualizer mode={mode} configA={configA} configB={configB} />
              </main>
            </div>
          );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>